# ProManage 后端代码与架构审计报告

**日期**: 2025年10月22日
**审计范围**: `F:\projects\ProManage\backend`

## 1. 总结

本次审计对 ProManage 后端项目进行了全面的代码和架构审查。项目采用现代化的技术栈（Java 21, Spring Boot 3），并构建了清晰的多模块结构。然而，在开发过程中，模块边界被严重破坏，`promanage-service` 模块承担了过多职责，几乎变成了一个单体应用。

审计发现了一个 **高危安全漏洞**，与权限缓存刷新机制相关，可能导致用户权限无法被及时撤销。此外，还识别出多处架构违规、代码质量问题和潜在的技术债务。

**核心结论**：项目基础良好，但急需一次彻底的重构来纠正架构偏差，并必须立即修复已发现的安全漏洞。

---

## 2. 审计发现与建议

### 2.1. 架构与设计 (严重)

#### 2.1.1. 模块边界严重破坏

*   **发现**: `promanage-service` 模块包含了本应属于其他模块的组件，包括：
    *   `dto` 包 (应在 `promanage-dto`)
    *   `security` 包 (应在 `promanage-infrastructure`)
    *   `mapper` 和 `entity` 包 (应在 `promanage-infrastructure` 或独立的持久化模块)
    *   一个空的 `controller` 包 (应在 `promanage-api`)
*   **影响**: 这种职责混淆完全破坏了多模块架构的优势，导致模块间高耦合、职责不清，增加了维护成本和新成员的学习曲线。
*   **建议**:
    *   **立即行动**: 制定重构计划，将错放在 `promanage-service` 模块中的所有包和类迁移到其应属的模块。
    *   **长期**: 建立更严格的合并前检查（Pull Request Review），确保不再发生此类架构违规。

#### 2.1.2. "上帝类" `UserServiceImpl`

*   **发现**: `UserServiceImpl` 类体积庞大，同时实现了 `IUserService` 和 Spring Security 的 `UserDetailsService`，并混合了业务逻辑、缓存管理、权限检查等多种职责。
*   **影响**: 违反单一职责原则，使代码难以理解、测试和维护。
*   **建议**:
    *   将 `UserDetailsService` 的实现拆分到独立的类中。
    *   将用户角色和权限管理的逻辑委托给专门的 `RoleService` 和 `PermissionService`。
    *   使用 AOP 或更高级的缓存注解来处理缓存逻辑，而不是在业务代码中手动驱逐。

### 2.2. 安全性 (高危)

#### 2.2.1. 权限缓存刷新机制缺陷 (高危)

*   **发现**: `UserServiceImpl` 中的 `getUserPermissions` 方法使用了 `@Cacheable("userPermissions")`。当管理员修改某个角色的权限集时，该缓存不会被主动清除。
*   **影响**: 已登录用户的权限无法被及时撤销。例如，一个用户的“编辑”角色被剥夺了“删除文档”的权限，但该用户在缓存过期前依然可以执行删除操作。这是一个 **高危安全漏洞**。
*   **建议**:
    *   **立即修复**: 移除 `getUserPermissions` 方法上的 `@Cacheable` 注解，以牺牲性能为代价确保安全。
    *   **彻底修复**: 实现一个事件监听机制。当角色权限发生变更时，发布一个事件，该事件的监听器负责清除所有拥有该角色的用户的权限缓存。

#### 2.2.2. 不安全的存根方法 (中危)

*   **发现**: `PermissionCheckService` 中的 `isProjectMember` 方法是一个存根，它总是返回 `true`。
*   **影响**: 如果该方法被用于 `@PreAuthorize` 注解，将导致权限检查被完全绕过。
*   **建议**: **立即** 实现该方法的正确逻辑，或在未实现前确保它没有在任何地方被使用。

#### 2.2.3. 权限检查逻辑不统一

*   **发现**: 系统中的权限检查逻辑散落在代码各处，使用了多种硬编码的 `if` 判断。
*   **影响**: 难以统一管理和审计权限，容易出错或遗漏。
*   **建议**: 全面采用 Spring Security 的方法级安全注解 (`@PreAuthorize`)，并结合自定义的 `PermissionCheckService`（在修复并迁移到 `infrastructure` 模块后）来实现声明式的、统一的权限控制。

### 2.3. 代码质量与技术债务 (中等)

#### 2.3.1. 静态代码检查规则过于宽松

*   **发现**: PMD 配置文件 (`pmd-ruleset.xml`) 中禁用了大量有价值的规则，如圈复杂度 (`CyclomaticComplexity`)、重复字面量 (`AvoidDuplicateLiterals`) 等。
*   **影响**: 静态代码分析工具的效果大打折扣，许多潜在的代码质量问题和技术债务被掩盖。
*   **建议**: 逐步重新启用被禁用的 PMD 规则，并设定一个计划来修复因此暴露出的历史代码问题。

#### 2.3.2. 实体类位置不统一

*   **发现**: `User` 实体在 `promanage-common` 模块，而 `Role` 和 `Permission` 实体在 `promanage-service` 模块。
*   **影响**: 项目结构不一致，给开发者带来困惑。
*   **建议**: 将所有核心领域实体统一迁移到一个位置，例如 `promanage-common` 或一个新的 `promanage-domain` 模块。

#### 2.3.3. 冗余和无效代码

*   **发现**: `IUserService` 接口中存在两个冗余的 `updatePassword` 方法。`UserServiceImpl` 的 `loadUserByUsername` 方法中存在无效的 `getUserPermissions` 调用。
*   **建议**: 清理这些冗余和无效的代码，保持代码库的整洁。

---

## 3. 优先级与行动计划

1.  **P0 (立即执行)**:
    *   修复 **权限缓存刷新机制缺陷** (2.2.1)。
    *   修复或移除 **不安全的存根方法** `isProjectMember` (2.2.2)。

2.  **P1 (短期内执行)**:
    *   执行架构重构，解决 **模块边界严重破坏** 的问题 (2.1.1)。
    *   将权限检查逻辑统一为 `@PreAuthorize` 注解 (2.2.3)。
    *   将所有实体类统一位置 (2.3.2)。

3.  **P2 (中期执行)**:
    *   重构 **"上帝类" `UserServiceImpl`** (2.1.2)。
    *   逐步恢复并修复 **静态代码检查** 规则 (2.3.1)。
    *   清理所有已发现的冗余和无效代码 (2.3.3)。
